#pragma kernel SHMain

// The input cubemap
TextureCube<float4> _Cubemap;

// The output buffer for the spherical harmonics coefficients
RWStructuredBuffer<float4> _SHCoefficients;

SamplerState LinearClampSampler : register(s0);

// Constants
static const float PI = 3.14159265358979323846264;
static const float TWO_PI = 6.28318530717958647692528;
static const float INV_GOLDEN_RATIO = 0.618033988749895;


float3 SphericalToCartesian(float theta, float phi) {
    float sinTheta = sin(theta);
    return float3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));
}

// SH basis functions for l=0, m=0..2
float Y00(float theta, float phi) { return 0.5 / sqrt(PI); }
float Y1_1(float theta, float phi) { return sqrt(3 / (4 * PI)) * sin(theta) * sin(phi); }
float Y10(float theta, float phi) { return sqrt(3 / (4 * PI)) * cos(theta); }
float Y11(float theta, float phi) { return sqrt(3 / (4 * PI)) * sin(theta) * cos(phi); }
float Y2_2(float theta, float phi) { return sqrt(15 / (4 * PI)) * sin(theta) * sin(theta) * sin(2 * phi); }
float Y2_1(float theta, float phi) { return sqrt(15 / (4 * PI)) * sin(2 * theta) * sin(phi); }
float Y20(float theta, float phi) { return sqrt(5 / (16 * PI)) * (3 * cos(theta) * cos(theta) - 1); }
float Y21(float theta, float phi) { return sqrt(15 / (4 * PI)) * sin(2 * theta) * cos(phi); }
float Y22(float theta, float phi) { return sqrt(15 / (4 * PI)) * sin(theta) * sin(theta) * cos(2 * phi); }


[numthreads(1, 1, 1)]
void SHMain(uint id : SV_DispatchThreadID) {
    uint sampleCount = 2000; // Number of samples
    float4 shCoefficients[9];
    [unroll]
    for (int f = 0; f < 9; ++f) {
        shCoefficients[f] = (float4)0;
    } 

    for (uint i = 0; i < sampleCount; ++i) {
        // Generate uniform points on the sphere using golden ratio
        float theta = acos(1 - 2 * (i + 0.5) / sampleCount);
        float phi = TWO_PI * INV_GOLDEN_RATIO * i;

        float3 dir = SphericalToCartesian(theta, phi);
        float4 sampleColor = _Cubemap.SampleLevel(LinearClampSampler, dir, 0);

        // Accumulate SH coefficients
        shCoefficients[0].rgb += sampleColor.rgb * Y00(theta, phi);
        shCoefficients[1].rgb += sampleColor.rgb * Y1_1(theta, phi);
        shCoefficients[2].rgb += sampleColor.rgb * Y10(theta, phi);
        shCoefficients[3].rgb += sampleColor.rgb * Y11(theta, phi);
        shCoefficients[4].rgb += sampleColor.rgb * Y2_2(theta, phi);
        shCoefficients[5].rgb += sampleColor.rgb * Y2_1(theta, phi);
        shCoefficients[6].rgb += sampleColor.rgb * Y20(theta, phi);
        shCoefficients[7].rgb += sampleColor.rgb * Y21(theta, phi);
        shCoefficients[8].rgb += sampleColor.rgb * Y22(theta, phi);
    }

    // Normalize SH coefficients by the number of samples and the weight of each sample (2*PI / sampleCount)
    float weight = 4.0 * PI / sampleCount;
    for (int j = 0; j < 9; ++j) {
        _SHCoefficients[j] = shCoefficients[j] * weight;
    }
}
